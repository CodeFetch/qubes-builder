#!/bin/bash --

# Usage: $0 <source-dir> [<ref>]
# Example refs:
#  master
#  HEAD
#  mainstream/master
# Default ref: HEAD

[ "$DEBUG" = "1" ] && set -x

# shellcheck source=scripts/common
source "$BUILDER_DIR/scripts/common"

set -o pipefail

if [ "$NO_CHECK" == "1" ]; then
    exit 0
fi

if [ -n "$KEYRING_DIR_GIT" ]; then
    export GNUPGHOME="$(readlink -m "$KEYRING_DIR_GIT")"
    if [ ! -d "$GNUPGHOME" ]; then
        mkdir -p "$GNUPGHOME"
        chmod 700 "$GNUPGHOME"
        gpg --import qubes-developers-keys.asc
        # Trust Qubes Master Signing Key
        echo '427F11FD0FAA4B080123F01CDDFA1A3E36879494:6:' | gpg --import-ownertrust
    fi
    if [ qubes-developers-keys.asc -nt "$GNUPGHOME/pubring.gpg" ]; then
        gpg --import qubes-developers-keys.asc
        touch "$GNUPGHOME/pubring.gpg"
    fi
    maintainers=$(env | grep -oP '^ALLOWED_COMPONENTS_[a-fA-F0-9]{40}')
    for maintainer in $maintainers
    do
        allowed_components=("${!maintainer}")
        COMPONENT="$(basename "$1")"
        COMPONENT="${COMPONENT//./builder}"
        if elementIn "$COMPONENT" ${allowed_components[@]}; then
            keyid=${maintainer#ALLOWED_COMPONENTS_}
            gpg --import "$BUILDER_DIR/keys/$keyid.asc" || exit 1
            echo "$keyid:6:" | gpg --import-ownertrust
        fi
    done
    gpgconf --kill gpg-agent
fi

pushd "$1" > /dev/null || exit 2

if [ -n "$2" ]; then
    REF="$2"
else
    REF="HEAD"
fi

verify_gpg_output () {
    local "content=$1" newsig_number
    newsig_number=$(printf %s\\n "$content" | grep -c '^\[GNUPG:] NEWSIG') || return 1
    [ "$newsig_number" = 1 ] && {
        printf %s\\n "$content" |
        grep '^\[GNUPG:] TRUST_\(FULLY\|ULTIMATE\) 0 pgp$' >/dev/null
    }
}

verify_tag() {
    local "tag=$1" "expected_hash=$2" hash
    if ! hash="$(git rev-parse -q --verify "$tag^{commit}")"; then
        echo "---> Failed to get tag hash">&2
        return 1
    elif ! [ "$hash" = "$expected_hash" ]; then
        printf %s\\n "---> Tag has wrong hash (found $hash, expected $expected_hash)">&2
        return 1
    fi
    content=$(git -c gpg.minTrustLevel=fully verify-tag --raw "$tag" 2>&1 >/dev/null) || return 1
    if verify_gpg_output "$content"; then
        printf %s\\n "---> Good tag ${tag:10}"
        return 0
    else
        return 1
    fi
}

VALID_TAG_FOUND=0
set -eu
case $REF in
(-*) echo 'Refs cannot begin with -'>&2; exit 1;;
esac
expected_hash=$REF
if [ "${#expected_hash}" -ne 40 ] && [ "${#expected_hash}" -ne 64 ]; then
    echo "---> Bad Git hash value (wrong length); failing" >&2
    exit 1
elif ! [[ "$expected_hash" =~ ^[a-f0-9]+$ ]]; then
    echo "---> Bad Git hash value (bad character); failing" >&2
    exit 1
fi

tags="$(git tag "--points-at=$REF"|head -c 500)" || exit 1
for tag in $tags; do
    tag="refs/tags/$tag"
    if verify_tag "$tag" "$expected_hash"; then
        VALID_TAG_FOUND=1
    elif [ "0${VERBOSE-}" -ge 1 ]; then
        echo "---> One of signed tag cannot be verified: $tag"
    fi
done

if [ "${tag+x}" != 'x' ]; then
    echo "---> No tag pointing at $REF"
    if content=$(git -c gpg.minTrustLevel=fully verify-commit --raw -- "$REF" 2>&1 >/dev/null) &&
        verify_gpg_output "$content"; then
        echo "---> $REF is a commit signed by a trusted key â€• did the signer forget to add a tag?"
    fi
    exit 1
elif [ "$VALID_TAG_FOUND" -ne 1 ]; then
    echo "No valid signed tag found!"
    if [ "0${VERBOSE-}" -eq 0 ]; then
        echo "---> One of invalid tag: $tag"
    fi
    exit 1
fi

exit 0
